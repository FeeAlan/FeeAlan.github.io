<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[adb command]]></title>
      <url>http://feisongbai.com/2016/09/10/command/</url>
      <content type="html"><![CDATA[<h1 id="安装app"><a href="#安装app" class="headerlink" title="安装app"></a>安装app</h1><p>先定位到apk的文件夹再执行下面的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$ adb install [appname.apk]</div><div class="line"> </div><div class="line">$ adb install -r [appname.apk]</div></pre></td></tr></table></figure></p>
<p>appname.apk 为安装文件的文件名</p>
<p>-r 意思为覆盖安装</p>
<hr>
<h1 id="复制文件到手机"><a href="#复制文件到手机" class="headerlink" title="复制文件到手机"></a>复制文件到手机</h1><p>先定位到要发送的文件的目录，再执行下面的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ adb push [filename] [mnt/sdcard/floder]</div></pre></td></tr></table></figure></p>
<p>filename 为文件名<br>mnt/sdcard/floder为接受文件的目的文件夹</p>
<hr>
<a id="more"></a>
<h1 id="查看apk文件的清单文件"><a href="#查看apk文件的清单文件" class="headerlink" title="查看apk文件的清单文件"></a>查看apk文件的清单文件</h1><p>先定位到apk文件目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ aapt dump xmltree [xxx.apk] AndroidManifest.xml</div></pre></td></tr></table></figure></p>
<p>xxx.apk为apk文件名</p>
<hr>
<h1 id="adb启动应用统计启动时间"><a href="#adb启动应用统计启动时间" class="headerlink" title="adb启动应用统计启动时间"></a>adb启动应用统计启动时间</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ adb shell am start -W -n com.xx.xx/.StartActivity</div></pre></td></tr></table></figure>
<p><code>com.xx.xx</code> 是包名      <code>.StartActivity</code> 为启动activity的相对路径</p>
<p><img src="http://ocnyep8a7.bkt.clouddn.com/16-9-10/32936060.jpg" alt="image"></p>
<ul>
<li><p>ThisTime : 表示连续启动的 Activity 中最后一个的启动耗时。</p>
</li>
<li><p>TotalTime : 表示启动耗时，包含了启动新的进程与和 Activity 的耗时。换句话说，就是你的应用自身启动的时间，从进程创建(如果需要)到窗口绘制完成。</p>
</li>
<li><p>WaitTime : 相对于 TotalTime，它额外包含了前一个应用的 Activity 的 Pause 耗时。</p>
</li>
</ul>
<p>所以通常来说我们只关注 TotalTime 即可。</p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[统一建模语言 UML 学习]]></title>
      <url>http://feisongbai.com/2016/08/26/UML-study/</url>
      <content type="html"><![CDATA[<h3 id="UML教程"><a href="#UML教程" class="headerlink" title="UML教程"></a>UML教程</h3><ul>
<li><a href="http://www.ibm.com/developerworks/cn/rational/321_uml/" target="_blank" rel="external">统一建模语言(UML) 版本 2.0</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/rational/rationaledge/content/feb05/bell/" target="_blank" rel="external">UML 基础: 类图</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/rational/rationaledge/content/feb05/bell/bell.html" target="_blank" rel="external">UML 基础: 组件图</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/rational/rationaledge/content/feb05/bell/3101.html" target="_blank" rel="external">UML 基础: 序列图</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/rational/tip-uml/index.html" target="_blank" rel="external">绘制整洁的 UML 图</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/rational/tip-uml/index2.html" target="_blank" rel="external">用例建模技巧</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/rational/tip-uml/index3.html" target="_blank" rel="external">UML 序列图简介</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/rational/tip-uml/index4.html" target="_blank" rel="external">养成良好的绘制 UML 序列图的习惯</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/rational/r-er/" target="_blank" rel="external">利用 UML 进行实体关系建模</a></li>
</ul>
<a id="more"></a>
<h3 id="UML绘图工具"><a href="#UML绘图工具" class="headerlink" title="UML绘图工具"></a>UML绘图工具</h3><h4 id="StartUML"><a href="#StartUML" class="headerlink" title="StartUML"></a><a href="http://staruml.io/" target="_blank" rel="external">StartUML</a></h4><ul>
<li><a href="http://staruml.io/download/release/v2.7.0/StarUML-v2.7.0.msi" target="_blank" rel="external">windows</a></li>
<li><a href="http://staruml.io/download/release/v2.7.0/StarUML-v2.7.0.dmg" target="_blank" rel="external">Mac OS X</a></li>
<li><a href="http://staruml.io/download/release/v2.7.0/StarUML-v2.7.0-64-bit.deb" target="_blank" rel="external">Linux (64-bit)</a></li>
<li><a href="http://staruml.io/download/release/v2.7.0/StarUML-v2.7.0-32-bit.deb" target="_blank" rel="external">Linux (32-bit)</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Activity 启动模式]]></title>
      <url>http://feisongbai.com/2016/08/26/android-start-model/</url>
      <content type="html"><![CDATA[<p>activity 启动模式分为四种：<strong>standard</strong>、<strong>singleTop</strong>、<strong>singleTask</strong>、<strong>singleInstance</strong>. </p>
<h2 id="1-standard"><a href="#1-standard" class="headerlink" title="1.standard"></a>1.standard</h2><p>标准启动模式，系统默认的启动方式。同一任务栈中可以存在多个activity实例。</p>
<p>如果activity A 的启动模式为<strong>standard</strong>，并且activity A已启动，此时再次启动activity A，则会在任务栈中创建一个新的activity A 实例。任务栈中的状态 A—&gt;A 。</p>
<h2 id="2-singleTop"><a href="#2-singleTop" class="headerlink" title="2. singleTop"></a>2. singleTop</h2><p>栈顶复用模式</p>
<p>设置activity A的启动模式是<strong>singleTop</strong>。</p>
<ul>
<li>如果现在栈顶位置<strong>已有</strong>activity A实例，则在启动该实例时<strong>不会</strong>创建新的实例。</li>
<li>如果现在栈顶位置<strong>不是</strong>activity A实例，则在启动该实例时会<strong>重新</strong>创建新的实例。</li>
<li>如果现在任务栈中<strong>没有</strong>activity A实例，则在启动该实例时会<strong>重新</strong>创建新的实例。</li>
</ul>
<a id="more"></a>
<h2 id="3-singleTask"><a href="#3-singleTask" class="headerlink" title="3. singleTask"></a>3. singleTask</h2><p>栈内复用模式</p>
<p>设置activity A的启动模式是<strong>singleTask</strong>。</p>
<ul>
<li>如果任务栈中存在activity A实例，不管其处在任务栈的什么位置，都会复用该实例，并且会把在其上面的activity全部出栈。</li>
<li>如果任务栈中不存在activity A，则会创建一个新的任务栈。</li>
</ul>
<h2 id="4-singleInstance"><a href="#4-singleInstance" class="headerlink" title="4. singleInstance"></a>4. singleInstance</h2><p>全局唯一模式</p>
<p>这种模式下的Activity会单独占用一个Task栈，具有全局唯一性，即整个系统中就这么一个实例，由于栈内复用的特性，后续的请求均不会创建新的Activity实例，除非这个特殊的任务栈被销毁了。以singleInstance模式启动的Activity在整个系统中是单例的，如果在启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[android BroadcastReciver]]></title>
      <url>http://feisongbai.com/2016/08/25/android-broadcast/</url>
      <content type="html"><![CDATA[<p><strong>android 系统的广播机制</strong></p>
<h2 id="一、广播机制简介"><a href="#一、广播机制简介" class="headerlink" title="一、广播机制简介"></a>一、广播机制简介</h2><p>android四大组件之一，是一种全局监听器，用于监听系统全局，可以接收来自系统和应用的广播。同时也能发送广播给其他应用。</p>
<h2 id="二、广播分类"><a href="#二、广播分类" class="headerlink" title="二、广播分类"></a>二、广播分类</h2><ol>
<li>标准广播：一种完全异步执行的广播，在广播发出之后，所有的广播接收器几乎都会在同一时间接收到这条广播消息，因此它们之间没有任何先后顺序可言。这种广播的效率比较高，无法被截断。</li>
<li>有序广播：一种同步执行的广播，在广播发出之后，同一时刻只会有一个广播接收器能够接收到这条广播消息，当这条广播接收器的逻辑执行完之后，广播消息才会继续传递。通过设置接收器的优先级，可以实现这一功能。优先级高的广播可以先接收到，同时还能截断该广播不往下传递。<a id="more"></a>
</li>
</ol>
<h2 id="三、-广播的使用"><a href="#三、-广播的使用" class="headerlink" title="三、 广播的使用"></a>三、 广播的使用</h2><h3 id="1）广播的注册方式"><a href="#1）广播的注册方式" class="headerlink" title="1）广播的注册方式"></a>1）广播的注册方式</h3><h4 id="1-静态注册"><a href="#1-静态注册" class="headerlink" title="1.静态注册"></a>1.<a name="section1" id="section1">静态注册</a></h4><pre><code>a. 写一个类继承BroadcastReceiver

    public class MyReceiver extends BroadcastReceiver {
        public MyReceiver() {
        }

        @Override
        public void onReceive(Context context, Intent intent) {

            Toast.makeText(context,&quot;......&quot;,Toast.LENGTH_SHORT).show();
        }
    }
b. 在AndroidManifest.xml中注册

    &lt;receiver android:name=&quot;com.feealan.blogtestdemo.MyReceiver&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;com.feealan.blogtestdemo.MY_BROADCAST&quot;/&gt;
        &lt;/intent-filter&gt;
    &lt;/receiver&gt;
c. 使用

    private void sendBroadcast() {
        Intent intent = new Intent();
        intent.setAction(&quot;com.feealan.blogtestdemo.MY_BROADCAST&quot;);
        sendBroadcast(intent);
    }
</code></pre><p> 总结：不管该应用是否启动，都会对其进行监听。</p>
<h4 id="2-动态注册"><a href="#2-动态注册" class="headerlink" title="2.动态注册"></a>2.动态注册</h4><pre><code>a. 写一个类继承BroadcastReceiver

    public class MyReceiver extends BroadcastReceiver {
        public MyReceiver() {
        }

        @Override
        public void onReceive(Context context, Intent intent) {

            Toast.makeText(context,&quot;......&quot;,Toast.LENGTH_SHORT).show();
        }
    }
b. 在AndroidManifest.xml中注册

        &lt;receiver android:name=&quot;com.feealan.blogtestdemo.MyReceiver&quot;&gt;
            &lt;intent-filter &gt;
                &lt;action android:name=&quot;com.feealan.blogtestdemo.MY_BROADCAST&quot;/&gt;
            &lt;/intent-filter&gt;
        &lt;/receiver&gt;
c. 直接使用

    //注册广播
    private void registerBroadcast() {
        IntentFilter filter = new IntentFilter();
        filter.addAction(&quot;com.feealan.blogtestdemo.MY_BROADCAST&quot;);
        MyReceiver receiver = new MyReceiver();
        registerReceiver(receiver, filter);
    }

    //发送广播
    private void sendBroadcast() {
        Intent intent = new Intent();
        intent.setAction(&quot;com.feealan.blogtestdemo.MY_BROADCAST&quot;);
        sendBroadcast(intent);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        //注销广播
        unregisterReceiver(receiver);
    }

总结：在代码中进行注册后，当应用程序关闭后，就不再进行监听
</code></pre><h3 id="2）广播的应用"><a href="#2）广播的应用" class="headerlink" title="2）广播的应用"></a>2）广播的应用</h3><h4 id="1-接收系统的广播"><a href="#1-接收系统的广播" class="headerlink" title="1.接收系统的广播"></a>1.接收系统的广播</h4><pre><code>请查看这篇文章 [**android 网络环境监听**](/2016/08/22/android-network-change-listen/index.html)
</code></pre><h4 id="2-发送自定义广播"><a href="#2-发送自定义广播" class="headerlink" title="2.发送自定义广播"></a>2.发送自定义广播</h4><pre><code>* 标准广播请看[广播的静态注册](#section1)
* 有序广播

    a. 写一个类继承BroadcastReceiver

        public class MyReceiver extends BroadcastReceiver {
            public MyReceiver() {
            }

            @Override
            public void onReceive(Context context, Intent intent) {

                Toast.makeText(context,&quot;......&quot;,Toast.LENGTH_SHORT).show();
            }
        }
    b. 在AndroidManifest.xml中注册

        &lt;receiver android:name=&quot;com.feealan.blogtestdemo.MyReceiver&quot;&gt;
            &lt;intent-filter android:priority=&quot;100&quot;&gt;
                &lt;action android:name=&quot;com.feealan.blogtestdemo.MY_BROADCAST&quot;/&gt;
            &lt;/intent-filter&gt;
        &lt;/receiver&gt;
    这里设置了优先级为100.这样该接收器可以比 **优先级** 比他低的 接收器先接收到到广播

    c. 使用

        private void sendBroadcast() {
            Intent intent = new Intent();
            intent.setAction(&quot;com.feealan.blogtestdemo.MY_BROADCAST&quot;);
             sendOrderedBroadcast(intent,null);
            //添加下面这句则截断广播
            //abortBroadcast();
        }
</code></pre><h4 id="3-本地广播"><a href="#3-本地广播" class="headerlink" title="3.本地广播"></a>3.本地广播</h4><pre><code>上面注册的广播都是全局性质的，系统所有的应用只要知道广播的**action**都会可以接收到该广播。如果该广播要传递重要的数据则会有安全问题，所以android系统引入了本地广播机制，该广播只能在应用内部使用。本地广播无法通过静态注册方式来注册接收。

a. 写一个类继承BroadcastReceiver

    public class LocalReciver extends BroadcastReceiver {
        public LocalReciver() {
        }

        @Override
        public void onReceive(Context context, Intent intent) {

            Toast.makeText(context,&quot;......&quot;,Toast.LENGTH_SHORT).show();
        }
    }
b. 在AndroidManifest.xml中注册

        &lt;receiver android:name=&quot;com.feealan.blogtestdemo.LocalReciver&quot;&gt;
            &lt;intent-filter &gt;
                &lt;action android:name=&quot;com.feealan.blogtestdemo.MY_BROADCAST&quot;/&gt;
            &lt;/intent-filter&gt;
        &lt;/receiver&gt;

c. 直接使用

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initView();
        //初始化本地广播管理器
        broadcastManager = LocalBroadcastManager.getInstance(this);
        register();
    }        

    //注册广播
    private void register() {
        IntentFilter filter = new IntentFilter();
        filter.addAction(&quot;com.feealan.blogtestdemo.MY_BROADCAST&quot;);
        LocalReciver receiver = new LocalReciver();
        broadcastManager.registerReceiver(receiver, filter);
    }

    //发送广播
    private void sendBroadcast() {
        Intent intent = new Intent();
        intent.setAction(&quot;com.feealan.blogtestdemo.MY_BROADCAST&quot;);
        broadcastManager.sendBroadcast(intent);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        //注销广播
        broadcastManager.unregisterReceiver(receiver);
    }
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[android 网络环境监听]]></title>
      <url>http://feisongbai.com/2016/08/22/android-network-change-listen/</url>
      <content type="html"><![CDATA[<h2 id="一、问题"><a href="#一、问题" class="headerlink" title="一、问题"></a>一、问题</h2><ol>
<li>判断用户是否联网</li>
<li>判断用户的网络环境，根据网络环境做数据加载的调整。例如：在wifi环境下做视频播放、大文件下载、多图加载、加载数据量增加等等，而在移动网络则为用户节省流量。</li>
</ol>
<h2 id="二、怎么解决问题"><a href="#二、怎么解决问题" class="headerlink" title="二、怎么解决问题"></a>二、怎么解决问题</h2><ol>
<li>判断手机的网络状态（无连接、移动网络、wifi）</li>
<li>当手机网络状态改变时发送广播<a id="more"></a>
</li>
</ol>
<h2 id="三、解决问题"><a href="#三、解决问题" class="headerlink" title="三、解决问题"></a>三、解决问题</h2><h3 id="1-编写网络状态管理器NetWorkManger"><a href="#1-编写网络状态管理器NetWorkManger" class="headerlink" title="1.编写网络状态管理器NetWorkManger"></a>1.编写网络状态管理器<strong>NetWorkManger</strong></h3><pre><code>    /**
     * 网络环境管理器
     */
public class NetWorkManger {
    /**
     * wifi 网络
     */
    public static final int NETWORK_TYPE_WIFI   = 0;
    /**
     * 2G 网络
     */
    public static final int NETWORK_TYPE_2G     = 1;
    /**
     * 3G 网络
     */
    public static final int NETWORK_TYPE_3G     = 2;
    /**
     * 4G 网络
     */
    public static final int NETWORK_TYPE_4G     = 3;
    /**
     * 无 网络
     */
    public static final int NETWORK_TYPE_INVALID = 4;
    /**
     * 网络是否连接
     *
     * @param context
     * @return
     */
    public static boolean isNetworkConnected(Context context) {
        ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkInfo         info = cm.getActiveNetworkInfo();
        return info != null &amp;&amp; info.isConnected();

    }

    /**
     * 获取网络类型
     * @param context
     * @return
     */
    public static int getNetworkType(Context context) {
        ConnectivityManager connectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkInfo         networkInfo         = connectivityManager.getActiveNetworkInfo();
        int networkType = 0;
        if (networkInfo != null &amp;&amp; networkInfo.isConnected()) {
            String type = networkInfo.getTypeName();
            if (type.equalsIgnoreCase(&quot;WIFI&quot;)) {
                networkType = NETWORK_TYPE_WIFI;
            } else if (type.equalsIgnoreCase(&quot;MOBILE&quot;)) {
                networkType = getMobileNetworkType(context);
            }
        } else {
            networkType = NETWORK_TYPE_INVALID;
        }
        return networkType;
    }


    /**
     * 判断在手机网络的情况下的网络类型
     *
     * @param context
     * @return
     */
    private static int getMobileNetworkType(Context context) {
        TelephonyManager mTelephonyManager = (TelephonyManager)
                context.getSystemService(Context.TELEPHONY_SERVICE);
        int networkType = mTelephonyManager.getNetworkType();
        switch (networkType) {
            case TelephonyManager.NETWORK_TYPE_GPRS:
            case TelephonyManager.NETWORK_TYPE_EDGE:
            case TelephonyManager.NETWORK_TYPE_CDMA:
            case TelephonyManager.NETWORK_TYPE_1xRTT:
            case TelephonyManager.NETWORK_TYPE_IDEN:
                return NETWORK_TYPE_2G;
            case TelephonyManager.NETWORK_TYPE_UMTS:
            case TelephonyManager.NETWORK_TYPE_EVDO_0:
            case TelephonyManager.NETWORK_TYPE_EVDO_A:
            case TelephonyManager.NETWORK_TYPE_HSDPA:
            case TelephonyManager.NETWORK_TYPE_HSUPA:
            case TelephonyManager.NETWORK_TYPE_HSPA:
            case TelephonyManager.NETWORK_TYPE_EVDO_B:
            case TelephonyManager.NETWORK_TYPE_EHRPD:
            case TelephonyManager.NETWORK_TYPE_HSPAP:
                return NETWORK_TYPE_3G;
            case TelephonyManager.NETWORK_TYPE_LTE:
                return NETWORK_TYPE_4G;
            default:
                return NETWORK_TYPE_INVALID;
        }
    }

}
</code></pre><h3 id="2-自定义一个网络状态改变接收器NetworkChangedReceiver"><a href="#2-自定义一个网络状态改变接收器NetworkChangedReceiver" class="headerlink" title="2.自定义一个网络状态改变接收器NetworkChangedReceiver"></a>2.自定义一个网络状态改变接收器<strong>NetworkChangedReceiver</strong></h3><pre><code>    /**
     * 网络改变接收器
     */
public class NetworkChangedReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        if (!NetWorkManger.isNetworkConnected(context)) {
            Toast.makeText(context, &quot;无网络连接&quot;, Toast.LENGTH_SHORT).show();
        } else {
            int networkType = NetWorkManger.getNetworkType(context);
            switch (networkType) {
                case NetWorkManger.NETWORK_TYPE_4G:
                case NetWorkManger.NETWORK_TYPE_3G:
                case NetWorkManger.NETWORK_TYPE_2G:
                    Toast.makeText(context, &quot;您当前处于移动网络&quot;, Toast.LENGTH_SHORT).show();
                    break;
                case NetWorkManger.NETWORK_TYPE_WIFI:
                    Toast.makeText(context, &quot;您当前处于wifi网络&quot;, Toast.LENGTH_SHORT).show();
                    break;
            }
        }
    }
}
</code></pre><h3 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h3><p>一般卸载基类<strong>BaseActivity</strong>中，在onCreate()中注册广播，在onDestroy()中注销广播。</p>
<pre><code> /**
  * 注册广播
  */
private void registerBroadcast() {
    IntentFilter filter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);
    changedBroadcast = new NetworkChangedReceiver();
    this.registerReceiver(changedBroadcast, filter);
}

@Override
protected void onDestroy() {
    super.onDestroy();
    //注销广播
    this.unregisterReceiver(changedBroadcast);
}
</code></pre><p>注意在清单文件中设置权限</p>
<pre><code>&lt;!--检测网络状态权限--&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;
&lt;!--网络请求权限--&gt;
&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[android 中线程的使用：更新UI]]></title>
      <url>http://feisongbai.com/2016/08/10/android-thread-study/</url>
      <content type="html"><![CDATA[<p>在android 4.0设置了一个规则：</p>
<blockquote>
<p>更新UI只能在主线程更新，那些耗时操作不能放在主线程中，防止主线程阻塞</p>
</blockquote>
<p>如果在主线程做耗时操作则会阻塞主线程，用户在此期间不能做任何交互，影响用户体验。Log显示为</p>
<pre><code>I/Choreographer: Skipped 3000 frames!  The application may be doing too much work on its main thread.
</code></pre><p>如果在子线程更新UI则会报错：</p>
<pre><code>FATAL EXCEPTION: Thread-109 
Process: com.feealan.blogtestdemo, PID: 8333  
android.view.ViewRootImp$CalledFromWrongThreadException:
 Only the original thread that created a view hierarchy can touch its views.
</code></pre><h2 id="一、问题"><a href="#一、问题" class="headerlink" title="一、问题"></a>一、问题</h2><p>通常在进行网络操作时，因为网络速率等一些原因，这一步操作的时间是未知的，因此一般把网络请求放到子线程中去做。那么这里就存在一个问题：<strong>请求到的数据如何显示到UI控件上？</strong></p>
<h2 id="二、寻求解决办法"><a href="#二、寻求解决办法" class="headerlink" title="二、寻求解决办法"></a>二、寻求解决办法</h2><p>android 系统根据这种情况专门设置的Handler机制，面对这种情况就轻而易举了。<br><a id="more"></a></p>
<h2 id="三、Handler机制"><a href="#三、Handler机制" class="headerlink" title="三、Handler机制"></a>三、Handler机制</h2><p>网上关于这方面的文章很多，主要有几点：<strong>Looper</strong> 、<strong>Handler</strong> 、<strong>Message</strong>.</p>
<ul>
<li><strong>Looper</strong> 主要有两个方法：<strong>prepare（）</strong>、<strong>loop()</strong>。<strong>prepare()</strong>方法会创建一个<strong>MessageQueue</strong>消息队列，<strong>loop()</strong>方法则是不断的去<strong>MessageQueue</strong>消息队列中取消息交给<strong>target</strong>的<strong>dispatchMessage</strong>去处理。</li>
<li><strong>Message</strong> 即消息实体，存放数据的地方</li>
<li><strong>Handler</strong> 处理和发送消息的类。主要有两个方法 sendMessage()、handleMessage().即一个发送数据，一个处理数据。</li>
</ul>
<h2 id="四、解决问题的几种方式"><a href="#四、解决问题的几种方式" class="headerlink" title="四、解决问题的几种方式"></a>四、解决问题的几种方式</h2><ol>
<li><p>使用handler，子线程中拿到数据，通过handler发送数据，在主线程加载数据。</p>
<pre><code>new Thread(){
    @Override
    public void run() {
      super.run();
      handler.sendEmptyMessage(1);
       }
}.start();

private Handler handler = new Handler() {
    @Override
    public void handleMessage(Message msg) {
        super.handleMessage(msg);
        Toast.makeText(UpdataUiAct.this,&quot;hello world&quot;,Toast.LENGTH_SHORT).show();
    }
};
</code></pre></li>
<li><p>使用activity的runOnUiThread()方法在子线程更新UI。</p>
<pre><code>new Thread(){
      @Override
      public void run() {
          super.run();
          runOnUiThread(new Runnable() {
                @Override
                public void run() {
                   Toast.makeText(UpdataUiAct.this, &quot;hello world&quot;, Toast.LENGTH_SHORT).show();
               }
            });
          }
}.start();
</code></pre></li>
<li><p>使用View.post(Runnable r)方法</p>
<pre><code>new Thread(){
   @Override
   public void run() {
      super.run();
      btn.post(new Runnable() {
         @Override
         public void run() {
            Toast.makeText(UpdataUiAct.this, &quot;hello world&quot;, Toast.LENGTH_SHORT).show();
        }
     });
  }
}.start();
</code></pre></li>
<li><p>使用AsyncTask </p>
<pre><code> class myAsync extends AsyncTask&lt;Void,Void,Void&gt;{

    @Override
    protected Void doInBackground(Void... voids) {
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return null;
    }

    @Override
    protected void onPostExecute(Void aVoid) {
        super.onPostExecute(aVoid);
        Toast.makeText(UpdataUiAct.this, &quot;hello world&quot;, Toast.LENGTH_SHORT).show();
    }
}
</code></pre></li>
<li>使用Eventbus<br> <a href="http://blog.csdn.net/harvic880925/article/details/40660137" target="_blank" rel="external">http://blog.csdn.net/harvic880925/article/details/40660137</a></li>
<li><p>使用广播</p>
<p> 在子线程获取到数据后，发送广播，把数据通过intent传递过去，在数据接收的地方接收广播。</p>
<p> 其实时间总线框架内部使用的广播机制，并进行了很好的封装。</p>
</li>
</ol>
<p>总结：android里更新UI，其实就是线程间的数据交互。android本身提供了一套很好的消息机制。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java 线程学习(三)]]></title>
      <url>http://feisongbai.com/2016/08/07/java-study-thread-three/</url>
      <content type="html"><![CDATA[<h1 id="线程的同步与锁"><a href="#线程的同步与锁" class="headerlink" title="线程的同步与锁"></a>线程的同步与锁</h1><h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h2><p>线程同步是为了防止多个线程操作同一个数据时，导致数据出错的问题。<br>例如： </p>
<p>数据bean    </p>
<pre><code>public class DataBean {
    private int d = 1000;
    public int getD() {
        return d;
    }
    public void setD(int x) {
        this.d -= x ;
    }
}
</code></pre><p>Runnable 接口</p>
<pre><code>public class AsyncRunnable implements Runnable{
    private DataBean dataBean = new DataBean();
    public void run() {
        for (int i = 0; i &lt; 3; i++) {
            this.dataBean.setD(i*10);
            System.out.println(Thread.currentThread().getName()+&quot; 当前d的值为：&quot;+ this.dataBean.getD());
        }
    }
    public static void main(String[] args) {
        AsyncRunnable runnable = new AsyncRunnable();
        Thread thread_a = new Thread(runnable,&quot;thread_a&quot;);
        Thread thread_b = new Thread(runnable,&quot;thread_b&quot;);

        thread_a.start();
        thread_b.start();

    }
}
</code></pre><p>结果：</p>
<pre><code>thread_a 当前d的值为：1000
thread_b 当前d的值为：1000
thread_b 当前d的值为：980
thread_b 当前d的值为：960
thread_a 当前d的值为：990
thread_a 当前d的值为：940
</code></pre><p>分析：</p>
<p>很明显结果不对，而且每一次运行结果都不同。<br><a id="more"></a></p>
<h2 id="2-解决问题"><a href="#2-解决问题" class="headerlink" title="2.解决问题"></a>2.解决问题</h2><p>就是将对数据Bean的访问加以限制，每次只能有一个线程在访问。</p>
<p>//todo  理解还不透彻</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java 线程学习(二)]]></title>
      <url>http://feisongbai.com/2016/08/06/java-study-thread-two/</url>
      <content type="html"><![CDATA[<p>阻塞状态详解，即让线程离开运行状态，进入到<strong>就绪</strong>状态。</p>
<h2 id="1-休眠"><a href="#1-休眠" class="headerlink" title="1.休眠"></a>1.休眠</h2><p>demo</p>
<pre><code>public class ThreadTest {
    public static void main(String[] args) {
        new Thread(){
            public void run() {
                long  t= System.currentTimeMillis(); 
                System.out.println(&quot;current time:&quot;+t);
                try {
                    sleep(1000);
                    System.out.println(&quot;current time:&quot;+System.currentTimeMillis());

                } catch (InterruptedException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
                System.out.println(&quot;d_value:&quot; + (System.currentTimeMillis()-t));
            };
        }.start();
    }
}
</code></pre><p>结果：</p>
<pre><code>current time:1470501743081
current time:1470501744081
d_value:1000
</code></pre><p>当前线程休眠1000 ms后继续执行。<br><a id="more"></a></p>
<h2 id="2-线程的让步"><a href="#2-线程的让步" class="headerlink" title="2. 线程的让步"></a>2. 线程的让步</h2><p>调用Thread.yield();暂停当前线程，进入到就绪状态，执行其他线程。其他线程根据优先级优先执行，不过不一定会执行线程优先级高的线程。优先级为1~10的数字。</p>
<p>设置线程优先级：</p>
<pre><code>Thread t = new MyThread();
t.setPriority(8);
t.start();
</code></pre><p>Thread类有三个优先级常量：</p>
<pre><code>static int MAX_PRIORITY   对应的值是 10
      线程可以具有的最高优先级。 
static int MIN_PRIORITY   对应的值为 1
      线程可以具有的最低优先级。 
static int NORM_PRIORITY  对应的值为 5
      分配给线程的默认优先级。
</code></pre><h2 id="3-线程的等待"><a href="#3-线程的等待" class="headerlink" title="3. 线程的等待"></a>3. 线程的等待</h2><p>调用Object.wait()；让线程挂起，等到执行notify()、notifyall()或者超时时被唤醒。wait有两种形式wait()和wait(milliseconds)。</p>
<p>与sleep()的区别：</p>
<ul>
<li>这两个方法来自不同的类分别是Thread和Object</li>
<li>最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。</li>
<li><p>wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在</p>
<pre><code>//任何地方使用
synchronized(x){
      x.notify()
     //或者wait()
}
</code></pre></li>
<li><p>sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常</p>
</li>
</ul>
<h2 id="4-线程的加入"><a href="#4-线程的加入" class="headerlink" title="4.线程的加入"></a>4.线程的加入</h2><p>调用join()方法。让一个线程A加入到线程B的尾部，线程B不执行完，A线程不执行。</p>
<pre><code>public class ThreadDemo {
    public static void main(String[] args) {
        System.out.println(&quot;main start&quot;);
        final Thread thread_A = new Thread(new Runnable() {

            public void run() {
                // TODO Auto-generated method stub
                for (int i = 0; i &lt; 10; i++) {
                    System.out.println(&quot;a:&quot;+i);

                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                }
                System.out.println(&quot;a:end&quot;);
            }
        });
        Thread thread_B = new Thread(new Runnable() {

            public void run() {
                // TODO Auto-generated method stub
                System.out.println(&quot;b  start&quot;);
                try {
                    thread_A.join();

                } catch (InterruptedException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
                System.out.println(&quot;b end&quot;);
            }
        });
        thread_A.start();
        thread_B.start();
        try {
            thread_B.join();
        } catch (InterruptedException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        System.out.println(&quot;main end&quot;);
    }    
}
</code></pre><p>结果：</p>
<pre><code>main start
b  start
a:0
a:1
a:2
a:3
a:4
a:5
a:6
a:7
a:8
a:9
a:end
b end
main end
</code></pre><p>结果分析：主线程加入线程B，必须等B执行完才继续工作。线程A加入线程B，线程B必须等A执行完毕再继续运行。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java 线程学习(一)]]></title>
      <url>http://feisongbai.com/2016/08/06/java-thread-study/</url>
      <content type="html"><![CDATA[<p>一直一来对于java多线程的知识不是理解特别透彻，在此对线程知识进行一次整理，加深对多线程的理解，方便到实际应用中。</p>
<h2 id="一、-进程与线程"><a href="#一、-进程与线程" class="headerlink" title="一、 进程与线程"></a>一、 进程与线程</h2><h3 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h3><p>操作系统中有多个程序，这里每个程序就是一个进程。进程指的是一个内存中运行的程序，每个进程都有自己独立的内存空间，一个进程可以启动多个线程。</p>
<h3 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h3><p>指的是进程中的一个执行单元，一个进程可以有多个线程。多个线程可以共享一个进程中的内存。</p>
<h3 id="3-举例-线程与进程的关系"><a href="#3-举例-线程与进程的关系" class="headerlink" title="3. 举例 线程与进程的关系"></a>3. 举例 线程与进程的关系</h3><p>把一个学校比作一个操作系统，班级比作是<strong>进程</strong>，班干部就是<strong>线程</strong>。一个学校里面可以有很多班级，相当于操作系统中有许多程序。各个班级都有自己的教室，即各个应用程序之间都存在一个独立的 <strong>内存空间</strong>中。班级中班干部做不同的任务，即某一进程中，可以有许多线程，执行不同的任务。<br><a id="more"></a></p>
<h2 id="二、-Java中的线程"><a href="#二、-Java中的线程" class="headerlink" title="二、 Java中的线程"></a>二、 Java中的线程</h2><h3 id="1-创建线程的方式"><a href="#1-创建线程的方式" class="headerlink" title="1. 创建线程的方式"></a>1. 创建线程的方式</h3><p>创建线程的方式有两种：</p>
<ol>
<li><p>实现Runnable接口，下面为该方法的示例</p>
<p> a.创建一个class NewThread </p>
<pre><code>public class NewThread implements Runnable{

    public void run() {
        // TODO Auto-generated method stub
        System.out.println(&quot;this is NewThread&quot;);
    }
}
</code></pre><p> b. 使用</p>
<pre><code>public class ThreadTest {
    public static void main(String[] args) {
        NewThread newThread = new NewThread();
        Thread thread = new Thread(newThread);
        thread.start();
    }
}
</code></pre><p> c.输出</p>
<p> this is NewThread</p>
</li>
<li><p>直接new Thread()即可创建一个线程，jdk中提供了以下的方法</p>
<pre><code>Thread() 
  分配新的 Thread 对象。
Thread(Runnable target) 
  分配新的 Thread 对象。
Thread(Runnable target, String name) 
  分配新的 Thread 对象。
Thread(String name) 
  分配新的 Thread 对象。
Thread(ThreadGroup group, Runnable target) 
  分配新的 Thread 对象。
Thread(ThreadGroup group, Runnable target, String name) 
  分配新的 Thread 对象，以便将 target 作为其运行对象，将指定的 name 作为其名称，并作为 group 所引用的线程组的一员。
Thread(ThreadGroup group, Runnable target, String name, long stackSize) 
  分配新的 Thread 对象，以便将 target 作为其运行对象，将指定的 name 作为其名称，作为 group 所引用的线程组的一员，并具有指定的堆栈大小。
Thread(ThreadGroup group, String name) 
  分配新的 Thread 对象。
</code></pre></li>
</ol>
<h3 id="2-线程的状态"><a href="#2-线程的状态" class="headerlink" title="2. 线程的状态"></a>2. 线程的状态</h3><p>线程一共有五个状态：新建–就绪–运行–阻塞–死亡</p>
<ol>
<li>新建：即刚开始创建一个新线程</li>
<li>就绪：线程有资格运行，但是调度程序还没有选定该线程可以运行，当调用了<strong>start（）</strong>方法之后，线程进入运行状态。线程从阻塞、休眠、等待状态回来后，进入到就绪状态。</li>
<li>运行：调度线程选定当前线程运行。</li>
<li>死亡：线程run()执行完成。也许这个线程还未移出栈，但是它的任务已执行完毕，存在没有意义。如果线程已死亡，则不能复生。</li>
<li>阻塞：当线程休眠、等待、阻塞时。例如执行了<strong>sleep（）、wait()</strong>，这个时候线程是没有死亡的，只是因为某些原因不能运行，但是还能回到运行状态。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[android studio 申请百度地图获取appkey]]></title>
      <url>http://feisongbai.com/2016/08/03/baidumap-apply-for-appkey/</url>
      <content type="html"><![CDATA[<h2 id="获取发布版SHA1-key"><a href="#获取发布版SHA1-key" class="headerlink" title="获取发布版SHA1 key"></a>获取发布版SHA1 key</h2><ol>
<li><p>先生成一个签名文件</p>
<blockquote>
<p>Build—Generate Signed APK</p>
</blockquote>
<p> 之后填写相关签名文件名称和密码，签名文件存放的位置，最好是放在项目的根目录</p>
</li>
<li><p>输入以下命令获取签名的SHA1值</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keytool -v -list -keystore [签名文件的绝对路径]</div></pre></td></tr></table></figure>
<p> 例如： </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keytool -v -list -keystore I:\demo\MyBaiduMapDemo\baidumap.jks</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="获取开发版SHA1-KEY"><a href="#获取开发版SHA1-KEY" class="headerlink" title="获取开发版SHA1 KEY"></a>获取开发版SHA1 KEY</h2><ol>
<li><p>输入以下命令</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keytool -v -list -keystore C:\Users\Administrator\.android\debug.keystore</div></pre></td></tr></table></figure>
<blockquote>
<p>C:\Users\Administrator.android\debug.keystore  是debug签名文件的绝对路径，默认是在该位置</p>
</blockquote>
<p> 要输入密码时 密码为  <strong>android</strong></p>
<a id="more"></a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[客户端与服务端同步时间]]></title>
      <url>http://feisongbai.com/2016/08/02/client-and-server-time-calibration/</url>
      <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p><strong>设计一个电影开始放映的倒计时的功能</strong>。正常情况下服务器把点击的放映时间传给客户端，然后客户端根据系统时间做倒计时。然而这里存在一些问题，可能导致不同的用户看到的倒计时不同。</p>
<ol>
<li>不同用户的系统时间可能不同</li>
<li>不同用户设置的时区不同</li>
</ol>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ol>
<li><strong>server</strong>当前的<code>Syetem.currentTimeMills()</code>发送给客户端，注意这个时间是<a href="http://baike.baidu.com/link?url=DVReuC7Bq-ymYSvaYw3PGyEnl8Z6M8LZbJHlqtJSuxunMSrfB6JNq_sDlPOjQIpo9sSkdpLLTj--AG8CQcdx_lS4WwPdYJr7z3y9ti0OtcU9zhdHkRmv7AJzC6bTih7r" target="_blank" rel="external"><strong>UTC</strong></a>时间。还有后台如果要给客户端发送时间数据，不要用<strong>Date</strong>，而是发送一个<strong>long</strong>类型的整数。</li>
<li><strong>client</strong>设置时区为<strong>GMT+8</strong>, <code>TimeZone.setDefault(TimeZone.getTimeZone(&quot;GMT+8&quot;));</code>,这里先考虑在东八区的情况，其他时区暂不考虑</li>
<li><p>编写方法同步client和server的时间</p>
<pre><code>private void asyncBetweenServerAndClientTime(long serverTime) {
    TimeZone.setDefault(TimeZone.getTimeZone(&quot;GMT+8&quot;));
    //时间差
    Long d_value = serverTime+8*60*60*1000
            -System.currentTimeMillis();
    // 保存 d_value
    ....
}
</code></pre></li>
</ol>
<ol>
<li>在倒计时的时间加上保存的<strong>d_value</strong>，这样就能保证在每个客户端看到的倒计时相同了<a id="more"></a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hexo发布新文章是自动打开编辑器]]></title>
      <url>http://feisongbai.com/2016/07/31/hexo-new-post-auto-open-markdown/</url>
      <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在使用hexo时，发现每次new post一篇文章，都要先输入命令<code>hexo new &quot;new post name&quot;</code>,然后再去文件夹里找刚才new的那篇文章，之后再用markdown打开，有点麻烦，万一文章多了的话一下还难得找到。</p>
<p>在网上找了一下解决了这个问题。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ol>
<li>该办法适用于hexo 3.0版本的</li>
<li>因为我用的是Windows系统，所以该办法适用于Windows，其他系统方法未知<a id="more"></a>
</li>
</ol>
<h3 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h3><ol>
<li>在项目根目录创建有个文件夹 <strong>scripts</strong></li>
<li>在文件夹内创建一个js文件 <strong>openfile.js</strong></li>
<li><p>文件内写入以下代码</p>
<pre><code>var exec = require(&apos;child_process&apos;).exec;

hexo.on(&apos;new&apos;, function(data){
    exec(&apos;start &quot;D:/Program Files/MarkdownPad 2/MarkdownPad2.exe&quot; &apos; + data.path);
});
</code></pre><p> 其中 <strong>D:/Program Files/MarkdownPad 2/MarkdownPad2.exe</strong>为markdown编辑器的绝对路径，我这里使用的是MarkdownPad2编辑器</p>
</li>
<li><p>保存好该文件之后，再使用命令新建一篇文章即可自动打开编辑器了</p>
<pre><code>hexo n &quot;post name&quot;
</code></pre></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[android 图片处理]]></title>
      <url>http://feisongbai.com/2016/07/31/android-image-compress/</url>
      <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><a id="more"></a>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[android 表单提交]]></title>
      <url>http://feisongbai.com/2016/07/24/android-html-post/</url>
      <content type="html"><![CDATA[<p>之前那个项目遇到一个需求，大概是这个样子：</p>
<blockquote>
<p>用户创建一个户外活动，可以设置时间、地点、主题、内容。。。。</p>
<p>在设定活动内容时可以添加文字和图片，且顺序是不确定的，用户可以随意选择插入图片和文字</p>
</blockquote>
<h2 id="那么问题来了"><a href="#那么问题来了" class="headerlink" title="那么问题来了"></a>那么问题来了</h2><ol>
<li>如何让用户插入文字和图片？</li>
<li>如何把这些数据参数提交到后台？</li>
<li>如何在客户端显示这些数据？</li>
</ol>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="富文本-webview"><a href="#富文本-webview" class="headerlink" title="富文本+webview"></a>富文本+webview</h3><ol>
<li>自定义一个富文本编辑控件，用户能够插入文字，图片；删除文字、图片。在<a href="https://github.com/" title="github" target="_blank" rel="external">Github</a>找了蛮久都没找到合适的，选择直接使用系统的<strong>EditText</strong>控件。</li>
<li>使用<strong>ImageSpan</strong>往<strong>EditTEXT</strong>插入一段 <strong>&lt; img src=””/&gt;</strong>片段：</li>
</ol>
<pre><code>    Bitmap bitmap = BitmapFactory.decodeFile(scaledFile.getAbsolutePath());
    // 根据Bitmap对象创建ImageSpan对象
    ImageSpan imageSpan = new ImageSpan(this, bitmap);
    // 创建一个SpannableString对象，以便插入用ImageSpan对象封装的图像
    String tempUrl = &quot;&lt;img src=\&quot;&quot; + path + &quot;\&quot; /&gt;&quot;;
    final SpannableString spannableString = new SpannableString(tempUrl);
    // 用ImageSpan对象替换你指定的字符串
    spannableString.setSpan(imageSpan, 0, tempUrl.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
    // 将选择的图片追加到EditText中光标所在位置
    final int index = et_act_content.getSelectionStart(); // 获取光标所在位置
    final Editable edit_text = et_act_content.getEditableText();
    handler.post(new Runnable() {
        @Override
        public void run() {
            if (index &lt; 0 || index &gt;= edit_text.length()) {
                edit_text.append(spannableString);
            } else {
                edit_text.insert(index, spannableString);
            }
        }
    });
使用**handler.post**是因为测试时在这里报错，editTEXT在拼接字符时有可能是个耗时操作
</code></pre><ol>
<li>在用户设置好活动内容后，点击发布活动，提交表单。在这一个操作中做三步处理：<ul>
<li>先把图片上传至服务器，然后服务器返回图片的地址，</li>
<li>客户端拿到地址后，分别把图片的地址插入到对应的img 标签的src属性中，这个时候Edittext中的内容其实是相当于一个html的片段 例如：<pre><code>**hello world&lt; img src=&quot;http://img.baidu.com/njkn.jpg&quot;/&gt;**
</code></pre></li>
<li>然后在把所有的内容提交到服务器</li>
</ul>
</li>
<li>编写一个固定的格式的html,固定的title、固定的时间显示，地址等等，</li>
<li><p>在客户端设置一个包含控件WebView的Fragment用于显示活动详情</p>
<pre><code>&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;title&quot;&gt;活动主题&lt;/div&gt;
    &lt;div class=&quot;time&quot;&gt;活动时间&lt;/div&gt;
    &lt;div class=&quot;content&quot;&gt;
        &lt;!--插入用户输入的活动内容--&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></li>
<li><p>客户端加载该活动详情网页是传入活动<strong>ID</strong>即可显示该活动的网页</p>
<p> 结果：基本上可以实现上述功能，但是存在问题。</p>
<ul>
<li>多文件上传的问题</li>
<li>网页加载时不好做适配</li>
<li>文字排版不太好看</li>
<li>网页加载很慢，常常是固定的部分先加载完成，然后动态的部分后加载，这个效果不太好</li>
</ul>
</li>
</ol>
<ol>
<li><p>根据存在的问题进行改进</p>
<ul>
<li>将固定格式的html作为资源文件存在客户端，每次加载网页的时候就加载该网页</li>
<li>根据ID向后台请求json数据，其中存在有html片段或者其他数据直接插入到该网页中，而不用每次都加载网页，加快加载速度</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[android TextView设置超链接]]></title>
      <url>http://feisongbai.com/2016/07/23/android-text-link/</url>
      <content type="html"><![CDATA[<p>今天在访问<a href="https://segmentfault.com/u/coding_fee" title="segmentfault" target="_blank" rel="external">segmentfault</a>时遇到一个这样的问题：<strong>如何为Textview设置超链接？</strong></p>
<p>通过查阅资料后，总结了一下。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>例如App在登录时让用户选择是否遵循某项规则或则条款，点击即可查看条款内容。如果内容过多则是跳转到一个静态网页。</li>
<li>在app做一个超链接的功能</li>
</ol>
<a id="more"></a>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ol>
<li><p>在<strong>XML</strong>文件中设置属性 <strong>android:autoLink=”web”</strong>即可</p>
<pre><code>&lt;TextView
  android:layout_width=&quot;match_parent&quot;
  android:layout_height=&quot;wrap_content&quot;
  android:text=&quot;http://www.baidu.com&quot;
  android:id=&quot;@+id/tv&quot;
  android:autoLink=&quot;web&quot;
  android:layout_marginTop=&quot;10dp&quot;/&gt;
</code></pre></li>
<li><p>在代码中设置 </p>
<pre><code>TextView tv = (TextView) findViewById(R.id.tv);
String html = &quot;百度一下：&quot;;
html+=&quot;&lt;a href= \&quot;http://www.baidu.com/\&quot;&gt;www.baidu.com&lt;/a&gt;&quot;;
CharSequence charSequence = Html.fromHtml(html);
tv.setText(charSequence);
//必须要设置下面这个属性
tv.setMovementMethod(LinkMovementMethod.getInstance());
</code></pre><ul>
<li>在设置textview的文本内容时链节的内容需要带上协议号 <strong>http</strong>或者<strong>https</strong>,如果不带上请加上这句属性 <strong>tv.setAutoLinkMask(Linkify.WEB_URLS);</strong></li>
<li>代码设置超链接时可以设置文字的颜色，添加下划线等功能</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[网络请求json解析时遇到的坑]]></title>
      <url>http://feisongbai.com/2016/07/18/network-gson-parse/</url>
      <content type="html"><![CDATA[<h1 id="1、网络请求数据返回的几种情况"><a href="#1、网络请求数据返回的几种情况" class="headerlink" title="1、网络请求数据返回的几种情况"></a>1、网络请求数据返回的几种情况</h1><ol>
<li>http返回状态码为404或者500错误，即请求未成功</li>
<li>http返回状态码为200，请求成功</li>
</ol>
<h1 id="2、网络请求数据成功返回的json数据格式"><a href="#2、网络请求数据成功返回的json数据格式" class="headerlink" title="2、网络请求数据成功返回的json数据格式"></a>2、网络请求数据成功返回的json数据格式</h1><pre><code>{
    &quot;data&quot;: &quot;&quot;,
    &quot;msg&quot;: &quot;success&quot;,
    &quot;status&quot;: 0  //这里 0代表成功  1代表失败
}     
</code></pre><p> 一般数据最外层都相同</p>
<blockquote>
<p><strong>status</strong> 即客户端和服务端商量好的状态码</p>
<p><strong>msg</strong>  即对status的一个解释</p>
<p><strong>data</strong> 存放数据</p>
</blockquote>
<a id="more"></a>
<h1 id="3、网络数据请求成功的几种情况"><a href="#3、网络数据请求成功的几种情况" class="headerlink" title="3、网络数据请求成功的几种情况"></a>3、网络数据请求成功的几种情况</h1><ol>
<li><strong>status</strong>为 1，数据请求失败，<strong>msg</strong>信息为 fail</li>
<li><strong>status</strong>为 0，数据加载成功，<strong>msg</strong>信息为 success，<strong>data</strong>内有数据</li>
<li><strong>status</strong>为 0，数据加载成功，<strong>msg</strong>信息为 success，<strong>data</strong>数据为空 显示为 <strong>“”</strong></li>
</ol>
<h1 id="4、针对上面的这三种情况，如果不做处理直接用Gson则会报以下的异常"><a href="#4、针对上面的这三种情况，如果不做处理直接用Gson则会报以下的异常" class="headerlink" title="4、针对上面的这三种情况，如果不做处理直接用Gson则会报以下的异常"></a>4、针对上面的这三种情况，如果不做处理直接用Gson则会报以下的异常</h1><pre><code>com.google.gson.JsonSyntaxException: java.lang.IllegalStateException: Expected BEGIN_OBJECT but was STRING at line 1 column 11
                                                                         at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter.read(ReflectiveTypeAdapterFactory.java:176)
                                                                         at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$1.read(ReflectiveTypeAdapterFactory.java:93)
                                                                         at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter.read(ReflectiveTypeAdapterFactory.java:172)
                                                                         at com.google.gson.Gson.fromJson(Gson.java:803)
                                                                         at com.google.gson.Gson.fromJson(Gson.java:768)
                                                                         at com.google.gson.Gson.fromJson(Gson.java:717)
                                                                         at com.google.gson.Gson.fromJson(Gson.java:689)
</code></pre><h1 id="5、解决办法（填坑过程）"><a href="#5、解决办法（填坑过程）" class="headerlink" title="5、解决办法（填坑过程）"></a>5、解决办法（填坑过程）</h1><ol>
<li>在使用gson解析时，对其抓取异常，在抓取到的异常中直接报系统错误。当时是有一种偷懒的想法，后来想想，这种办法把 请求成功中的第一第二种情况合到一起解决了，<strong>不可取</strong></li>
<li><p>和后台商量，如果数据加载失败，则返回的json为</p>
<pre><code>{&quot;msg&quot;: &quot;fail&quot;,&quot;status&quot;: 1}
</code></pre><p>如果数据为空，则返回的data也必须和有数据时类型一样，即下面这种情况，数据为空时给其一个默认值</p>
<p> 正常数据：</p>
<pre><code>{
    &quot;data&quot;: {
        &quot;username&quot;: &quot;fee&quot;,
        &quot;age&quot;: 20,
        &quot;sex&quot;: 1
    },
    &quot;msg&quot;: &quot;success&quot;,
    &quot;status&quot;: 0
}
</code></pre><p> 数据为空：</p>
<pre><code>{
    &quot;data&quot;: {},
    &quot;msg&quot;: &quot;success&quot;,
    &quot;status&quot;: 0
}
</code></pre><p> 默认值设置标准：正常情况下返回的类型是什么，则默认值的类型是什么<br> 解释：</p>
<ol>
<li>如果返回的数据为字符串，为空返回 <strong>“”</strong></li>
<li>如果返回的数据为对象，为空返回 <strong>｛｝</strong></li>
<li>如果返回的数据为集合，为空返回 <strong>[]</strong></li>
</ol>
</li>
<li><p>客户端在解析数据时，编写一个解析工具类 </p>
<p> <strong>JsonUtil</strong></p>
<pre><code>public class JsonUtil {
    public static Object parse(String json, Type type) {
        JSONObject object = null;
        try {
            object = new JSONObject(json);
            int status = object.getInt(&quot;status&quot;);
            String msg = object.getString(&quot;msg&quot;);
            Gson gson = new Gson();
            if (status == 1) {//数据请求失败
                return gson.fromJson(json, type);
            } else if (status == 0) {//数据请求成功
                if (!object.getString(&quot;data&quot;).equals(&quot;&quot;) &amp;&amp; !&quot;&quot;.equals(object.getString(&quot;data&quot;))) {//数据不为空
                    return gson.fromJson(json, type);
                } else {
                    return null;
                }
            }
        } catch (JSONException e) {
            e.printStackTrace();
            LogUtils.e(e.getMessage());
            return null;
        } catch (JsonSyntaxException e) {
            e.printStackTrace();
            LogUtils.e(e.getMessage());
            return null;
        } catch (NullPointerException e) {
            e.printStackTrace();
            LogUtils.e(e.getMessage());
            return null;
        }
        return null;
    }
}
</code></pre><p>  调用：</p>
<pre><code>LogUtils.d(data);
Type     type = new TypeToken&lt;TestBean&gt;() {}.getType();
        try {
            TestBean bean = (TestBean) JsonUtil.parse(data, type);
            if (bean != null) {
                if (bean.getStatus() == 0) {
                    LogUtils.d(&quot;DATA::&quot; + bean.getData().getData());
                    if (bean.getData().getData() == null) {
                        LogUtils.d(&quot;数据为空::::::::&quot;);
                    } else {
                        LogUtils.d(bean.getData().toString());
                    }
                } else {
                    LogUtils.d(&quot;数据加载失败&quot;);
                }
            } else {
                LogUtils.d(&quot;数据为空..........&quot;);
            }
        } catch (ClassCastException e) {
            e.printStackTrace();
            LogUtils.e(e.getMessage());
        }
</code></pre></li>
</ol>
<blockquote>
<p><strong>ps</strong>:该解决办法自己做过测试可行，但是并不完美，以后有更好的解决办法在来修改</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android 序列化与反序列化]]></title>
      <url>http://feisongbai.com/2016/07/17/Serialize-and-Deserialize/</url>
      <content type="html"><![CDATA[<h2 id="1、什么是序列化与反序列化"><a href="#1、什么是序列化与反序列化" class="headerlink" title="1、什么是序列化与反序列化"></a>1、什么是序列化与反序列化</h2><blockquote>
<p>序列化：将数据结构或对象转换成二进制串的过程</p>
<p>反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程</p>
</blockquote>
<h2 id="2、为什么要序列化与反序列化"><a href="#2、为什么要序列化与反序列化" class="headerlink" title="2、为什么要序列化与反序列化"></a>2、为什么要序列化与反序列化</h2><blockquote>
<p>由于在系统底层，数据的传输形式是简单的字节序列形式传递，即在底层，系统不认识对象，只认识字节序列，而为了达到进程通讯的目的，需要先将数据序列化，而序列化就是将对象转化字节序列的过程。</p>
<p>相反地，当字节序列被运到相应的进程的时候，进程为了识别这些数据，就要将其反序列化，即把字节序列转化为对象。</p>
</blockquote>
<a id="more"></a>
<h2 id="3、Android-什么时候使用到序列化"><a href="#3、Android-什么时候使用到序列化" class="headerlink" title="3、Android 什么时候使用到序列化"></a>3、Android 什么时候使用到序列化</h2><h3 id="1、使用Intent传递对象时，该对象必须序列化"><a href="#1、使用Intent传递对象时，该对象必须序列化" class="headerlink" title="1、使用Intent传递对象时，该对象必须序列化"></a>1、使用Intent传递对象时，该对象必须序列化</h3><pre><code>Intent intent = new Intent(MainActivity.this, TestActivity.class);
intent.putExtra(&quot;user&quot;, new TestBean());
startActivity(intent);
</code></pre><h3 id="2、把内存中的对象写入到硬盘的时候"><a href="#2、把内存中的对象写入到硬盘的时候" class="headerlink" title="2、把内存中的对象写入到硬盘的时候"></a>2、把内存中的对象写入到硬盘的时候</h3><pre><code>/**
 * 序列化对象
 * 
 * @param person
 * @throws IOException
 * @return
 */
private String serialize(Person person) throws IOException {
    startTime = System.currentTimeMillis();
    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
    ObjectOutputStream objectOutputStream = new ObjectOutputStream(
            byteArrayOutputStream);
    objectOutputStream.writeObject(person);
    String serStr = byteArrayOutputStream.toString(&quot;ISO-8859-1&quot;);
    serStr = java.net.URLEncoder.encode(serStr, &quot;UTF-8&quot;);
    objectOutputStream.close();
    byteArrayOutputStream.close();
    Log.d(&quot;serial&quot;, &quot;serialize str =&quot; + serStr);
    endTime = System.currentTimeMillis();
    Log.d(&quot;serial&quot;, &quot;序列化耗时为:&quot; + (endTime - startTime));
    return serStr;
}
</code></pre><h3 id="3、想在网络中传送和接收对象的时候"><a href="#3、想在网络中传送和接收对象的时候" class="headerlink" title="3、想在网络中传送和接收对象的时候"></a>3、想在网络中传送和接收对象的时候</h3><pre><code>使用json来进行客户端和服务端通信，json的解析与生成就是数据的序列化和反序列化
</code></pre><h2 id="4、Android-对象序列化"><a href="#4、Android-对象序列化" class="headerlink" title="4、Android 对象序列化"></a>4、Android 对象序列化</h2><h3 id="1、实现Serializable接口"><a href="#1、实现Serializable接口" class="headerlink" title="1、实现Serializable接口"></a>1、实现Serializable接口</h3><pre><code>public class TestBean  implements Serializable{
    private String name;
    private String sex;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }
}
</code></pre><h3 id="2、实现Parcelable接口"><a href="#2、实现Parcelable接口" class="headerlink" title="2、实现Parcelable接口"></a>2、实现Parcelable接口</h3><pre><code>public class TestBean implements Parcelable {
    private String name;
    private String sex;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(this.name);
        dest.writeString(this.sex);
    }

    public TestBean() {
    }

    protected TestBean(Parcel in) {
        this.name = in.readString();
        this.sex = in.readString();
    }

    public static final Parcelable.Creator&lt;TestBean&gt; CREATOR = new Parcelable.Creator&lt;TestBean&gt;() {
        @Override
        public TestBean createFromParcel(Parcel source) {
            return new TestBean(source);
        }

        @Override
        public TestBean[] newArray(int size) {
            return new TestBean[size];
        }
    };
}
</code></pre><p>推荐一个android studio实现Parcelable接口的插件，可以快速实现Parcelable自动生成代码</p>
<blockquote>
<p><strong>File</strong>&gt;&gt;&gt;<strong>Setting</strong>&gt;&gt;&gt;<strong>Plugins</strong>&gt;&gt;&gt;<strong>Browse respositories</strong>&gt;&gt;&gt;搜索<strong>Parcelable</strong>&gt;&gt;&gt;<br>选择<strong>Android Parcelable code generator</strong>&gt;&gt;&gt;<strong>install</strong></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://feisongbai.com/2016/07/14/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
