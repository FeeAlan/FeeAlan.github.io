<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[客户端与服务端同步时间]]></title>
      <url>https://feealan.github.io/2016/08/02/client-and-server-time-calibration/</url>
      <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p><strong>设计一个电影开始放映的倒计时的功能</strong>。正常情况下服务器把点击的放映时间传给客户端，然后客户端根据系统时间做倒计时。然而这里存在一些问题，可能导致不同的用户看到的倒计时不同。</p>
<ol>
<li>不同用户的系统时间可能不同</li>
<li>不同用户设置的时区不同</li>
</ol>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ol>
<li><strong>server</strong>当前的<code>Syetem.currentTimeMills()</code>发送给客户端，注意这个时间是<a href="http://baike.baidu.com/link?url=DVReuC7Bq-ymYSvaYw3PGyEnl8Z6M8LZbJHlqtJSuxunMSrfB6JNq_sDlPOjQIpo9sSkdpLLTj--AG8CQcdx_lS4WwPdYJr7z3y9ti0OtcU9zhdHkRmv7AJzC6bTih7r" target="_blank" rel="external"><strong>UTC</strong></a>时间。还有后台如果要给客户端发送时间数据，不要用<strong>Date</strong>，而是发送一个<strong>long</strong>类型的整数。</li>
<li><strong>client</strong>设置时区为<strong>GMT+8</strong>, <code>TimeZone.setDefault(TimeZone.getTimeZone(&quot;GMT+8&quot;));</code>,这里先考虑在东八区的情况，其他时区暂不考虑</li>
<li><p>编写方法同步client和server的时间</p>
<pre><code>private void asyncBetweenServerAndClientTime(long serverTime) {
    TimeZone.setDefault(TimeZone.getTimeZone(&quot;GMT+8&quot;));
    //时间差
    Long d_value = serverTime+8*60*60*1000
            -System.currentTimeMillis();
    // 保存 d_value
    ....
}
</code></pre></li>
</ol>
<ol>
<li>在倒计时的时间加上保存的<strong>d_value</strong>，这样就能保证在每个客户端看到的倒计时相同了<a id="more"></a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hexo发布新文章是自动打开编辑器]]></title>
      <url>https://feealan.github.io/2016/07/31/hexo-new-post-auto-open-markdown/</url>
      <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在使用hexo时，发现每次new post一篇文章，都要先输入命令<code>hexo new &quot;new post name&quot;</code>,然后再去文件夹里找刚才new的那篇文章，之后再用markdown打开，有点麻烦，万一文章多了的话一下还难得找到。</p>
<p>在网上找了一下解决了这个问题。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ol>
<li>该办法适用于hexo 3.0版本的</li>
<li>因为我用的是Windows系统，所以该办法适用于Windows，其他系统方法未知<a id="more"></a>
</li>
</ol>
<h3 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h3><ol>
<li>在项目根目录创建有个文件夹 <strong>scripts</strong></li>
<li>在文件夹内创建一个js文件 <strong>openfile.js</strong></li>
<li><p>文件内写入以下代码</p>
<pre><code>var exec = require(&apos;child_process&apos;).exec;

hexo.on(&apos;new&apos;, function(data){
    exec(&apos;start &quot;D:/Program Files/MarkdownPad 2/MarkdownPad2.exe&quot; &apos; + data.path);
});
</code></pre><p> 其中 <strong>D:/Program Files/MarkdownPad 2/MarkdownPad2.exe</strong>为markdown编辑器的绝对路径，我这里使用的是MarkdownPad2编辑器</p>
</li>
<li><p>保存好该文件之后，再使用命令新建一篇文章即可自动打开编辑器了</p>
<pre><code>hexo n &quot;post name&quot;
</code></pre></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[android 图片处理]]></title>
      <url>https://feealan.github.io/2016/07/31/android-image-compress/</url>
      <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>开发app时图片处理一直是个比较头疼的问题，下面的问题常常会遇到</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[android 表单提交]]></title>
      <url>https://feealan.github.io/2016/07/24/android-html-post/</url>
      <content type="html"><![CDATA[<p>之前那个项目遇到一个需求，大概是这个样子：</p>
<blockquote>
<p>用户创建一个户外活动，可以设置时间、地点、主题、内容。。。。</p>
<p>在设定活动内容时可以添加文字和图片，且顺序是不确定的，用户可以随意选择插入图片和文字</p>
</blockquote>
<h2 id="那么问题来了"><a href="#那么问题来了" class="headerlink" title="那么问题来了"></a>那么问题来了</h2><ol>
<li>如何让用户插入文字和图片？</li>
<li>如何把这些数据参数提交到后台？</li>
<li>如何在客户端显示这些数据？</li>
</ol>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="富文本-webview"><a href="#富文本-webview" class="headerlink" title="富文本+webview"></a>富文本+webview</h3><ol>
<li>自定义一个富文本编辑控件，用户能够插入文字，图片；删除文字、图片。在<a href="https://github.com/" title="github" target="_blank" rel="external">https://github.com/</a>找了蛮久都没找到合适的，选择直接使用系统的<strong>EditText</strong>控件。</li>
<li>使用<strong>ImageSpan</strong>往<strong>EditTEXT</strong>插入一段 <strong>&lt; img src=””/&gt;</strong>片段：</li>
</ol>
<pre><code>    Bitmap bitmap = BitmapFactory.decodeFile(scaledFile.getAbsolutePath());
    // 根据Bitmap对象创建ImageSpan对象
    ImageSpan imageSpan = new ImageSpan(this, bitmap);
    // 创建一个SpannableString对象，以便插入用ImageSpan对象封装的图像
    String tempUrl = &quot;&lt;img src=\&quot;&quot; + path + &quot;\&quot; /&gt;&quot;;
    final SpannableString spannableString = new SpannableString(tempUrl);
    // 用ImageSpan对象替换你指定的字符串
    spannableString.setSpan(imageSpan, 0, tempUrl.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
    // 将选择的图片追加到EditText中光标所在位置
    final int index = et_act_content.getSelectionStart(); // 获取光标所在位置
    final Editable edit_text = et_act_content.getEditableText();
    handler.post(new Runnable() {
        @Override
        public void run() {
            if (index &lt; 0 || index &gt;= edit_text.length()) {
                edit_text.append(spannableString);
            } else {
                edit_text.insert(index, spannableString);
            }
        }
    });
使用**handler.post**是因为测试时在这里报错，editTEXT在拼接字符时有可能是个耗时操作
</code></pre><ol>
<li>在用户设置好活动内容后，点击发布活动，提交表单。在这一个操作中做三步处理：<ul>
<li>先把图片上传至服务器，然后服务器返回图片的地址，</li>
<li>客户端拿到地址后，分别把图片的地址插入到对应的img 标签的src属性中，这个时候Edittext中的内容其实是相当于一个html的片段 例如：<pre><code>**hello world&lt; img src=&quot;http://img.baidu.com/njkn.jpg&quot;/&gt;**
</code></pre></li>
<li>然后在把所有的内容提交到服务器</li>
</ul>
</li>
<li>编写一个固定的格式的html,固定的title、固定的时间显示，地址等等，</li>
<li><p>在客户端设置一个包含控件WebView的Fragment用于显示活动详情</p>
<pre><code>&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;title&quot;&gt;活动主题&lt;/div&gt;
    &lt;div class=&quot;time&quot;&gt;活动时间&lt;/div&gt;
    &lt;div class=&quot;content&quot;&gt;
        &lt;!--插入用户输入的活动内容--&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></li>
<li><p>客户端加载该活动详情网页是传入活动<strong>ID</strong>即可显示该活动的网页</p>
<p> 结果：基本上可以实现上述功能，但是存在问题。</p>
<ul>
<li>多文件上传的问题</li>
<li>网页加载时不好做适配</li>
<li>文字排版不太好看</li>
<li>网页加载很慢，常常是固定的部分先加载完成，然后动态的部分后加载，这个效果不太好</li>
</ul>
</li>
</ol>
<ol>
<li><p>根据存在的问题进行改进</p>
<ul>
<li>将固定格式的html作为资源文件存在客户端，每次加载网页的时候就加载该网页</li>
<li>根据ID向后台请求json数据，其中存在有html片段或者其他数据直接插入到该网页中，而不用每次都加载网页，加快加载速度</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[android TextView设置超链接]]></title>
      <url>https://feealan.github.io/2016/07/23/android-text-link/</url>
      <content type="html"><![CDATA[<p>今天在访问<a href="https://segmentfault.com/u/coding_fee" title="segmentfault" target="_blank" rel="external">segmentfault</a>时遇到一个这样的问题：<strong>如何为Textview设置超链接？</strong></p>
<p>通过查阅资料后，总结了一下。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>例如App在登录时让用户选择是否遵循某项规则或则条款，点击即可查看条款内容。如果内容过多则是跳转到一个静态网页。</li>
<li>在app做一个超链接的功能</li>
</ol>
<a id="more"></a>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ol>
<li><p>在<strong>XML</strong>文件中设置属性 <strong>android:autoLink=”web”</strong>即可</p>
<pre><code>&lt;TextView
  android:layout_width=&quot;match_parent&quot;
  android:layout_height=&quot;wrap_content&quot;
  android:text=&quot;http://www.baidu.com&quot;
  android:id=&quot;@+id/tv&quot;
  android:autoLink=&quot;web&quot;
  android:layout_marginTop=&quot;10dp&quot;/&gt;
</code></pre></li>
<li><p>在代码中设置 </p>
<pre><code>TextView tv = (TextView) findViewById(R.id.tv);
String html = &quot;百度一下：&quot;;
html+=&quot;&lt;a href= \&quot;http://www.baidu.com/\&quot;&gt;www.baidu.com&lt;/a&gt;&quot;;
CharSequence charSequence = Html.fromHtml(html);
tv.setText(charSequence);
//必须要设置下面这个属性
tv.setMovementMethod(LinkMovementMethod.getInstance());
</code></pre><ul>
<li>在设置textview的文本内容时链节的内容需要带上协议号 <strong>http</strong>或者<strong>https</strong>,如果不带上请加上这句属性 <strong>tv.setAutoLinkMask(Linkify.WEB_URLS);</strong></li>
<li>代码设置超链接时可以设置文字的颜色，添加下划线等功能</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[网络请求json解析时遇到的坑]]></title>
      <url>https://feealan.github.io/2016/07/18/network-gson-parse/</url>
      <content type="html"><![CDATA[<h1 id="1、网络请求数据返回的几种情况"><a href="#1、网络请求数据返回的几种情况" class="headerlink" title="1、网络请求数据返回的几种情况"></a>1、网络请求数据返回的几种情况</h1><ol>
<li>http返回状态码为404或者500错误，即请求未成功</li>
<li>http返回状态码为200，请求成功</li>
</ol>
<h1 id="2、网络请求数据成功返回的json数据格式"><a href="#2、网络请求数据成功返回的json数据格式" class="headerlink" title="2、网络请求数据成功返回的json数据格式"></a>2、网络请求数据成功返回的json数据格式</h1><pre><code>{
    &quot;data&quot;: &quot;&quot;,
    &quot;msg&quot;: &quot;success&quot;,
    &quot;status&quot;: 0  //这里 0代表成功  1代表失败
}     
</code></pre><p> 一般数据最外层都相同</p>
<blockquote>
<p><strong>status</strong> 即客户端和服务端商量好的状态码</p>
<p><strong>msg</strong>  即对status的一个解释</p>
<p><strong>data</strong> 存放数据</p>
</blockquote>
<a id="more"></a>
<h1 id="3、网络数据请求成功的几种情况"><a href="#3、网络数据请求成功的几种情况" class="headerlink" title="3、网络数据请求成功的几种情况"></a>3、网络数据请求成功的几种情况</h1><ol>
<li><strong>status</strong>为 1，数据请求失败，<strong>msg</strong>信息为 fail</li>
<li><strong>status</strong>为 0，数据加载成功，<strong>msg</strong>信息为 success，<strong>data</strong>内有数据</li>
<li><strong>status</strong>为 0，数据加载成功，<strong>msg</strong>信息为 success，<strong>data</strong>数据为空 显示为 <strong>“”</strong></li>
</ol>
<h1 id="4、针对上面的这三种情况，如果不做处理直接用Gson则会报以下的异常"><a href="#4、针对上面的这三种情况，如果不做处理直接用Gson则会报以下的异常" class="headerlink" title="4、针对上面的这三种情况，如果不做处理直接用Gson则会报以下的异常"></a>4、针对上面的这三种情况，如果不做处理直接用Gson则会报以下的异常</h1><pre><code>com.google.gson.JsonSyntaxException: java.lang.IllegalStateException: Expected BEGIN_OBJECT but was STRING at line 1 column 11
                                                                         at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter.read(ReflectiveTypeAdapterFactory.java:176)
                                                                         at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$1.read(ReflectiveTypeAdapterFactory.java:93)
                                                                         at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter.read(ReflectiveTypeAdapterFactory.java:172)
                                                                         at com.google.gson.Gson.fromJson(Gson.java:803)
                                                                         at com.google.gson.Gson.fromJson(Gson.java:768)
                                                                         at com.google.gson.Gson.fromJson(Gson.java:717)
                                                                         at com.google.gson.Gson.fromJson(Gson.java:689)
</code></pre><h1 id="5、解决办法（填坑过程）"><a href="#5、解决办法（填坑过程）" class="headerlink" title="5、解决办法（填坑过程）"></a>5、解决办法（填坑过程）</h1><ol>
<li>在使用gson解析时，对其抓取异常，在抓取到的异常中直接报系统错误。当时是有一种偷懒的想法，后来想想，这种办法把 请求成功中的第一第二种情况合到一起解决了，<strong>不可取</strong></li>
<li><p>和后台商量，如果数据加载失败，则返回的json为</p>
<pre><code>{&quot;msg&quot;: &quot;fail&quot;,&quot;status&quot;: 1}
</code></pre><p>如果数据为空，则返回的data也必须和有数据时类型一样，即下面这种情况，数据为空时给其一个默认值</p>
<p> 正常数据：</p>
<pre><code>{
    &quot;data&quot;: {
        &quot;username&quot;: &quot;fee&quot;,
        &quot;age&quot;: 20,
        &quot;sex&quot;: 1
    },
    &quot;msg&quot;: &quot;success&quot;,
    &quot;status&quot;: 0
}
</code></pre><p> 数据为空：</p>
<pre><code>{
    &quot;data&quot;: {},
    &quot;msg&quot;: &quot;success&quot;,
    &quot;status&quot;: 0
}
</code></pre><p> 默认值设置标准：正常情况下返回的类型是什么，则默认值的类型是什么<br> 解释：</p>
<ol>
<li>如果返回的数据为字符串，为空返回 <strong>“”</strong></li>
<li>如果返回的数据为对象，为空返回 <strong>｛｝</strong></li>
<li>如果返回的数据为集合，为空返回 <strong>[]</strong></li>
</ol>
</li>
<li><p>客户端在解析数据时，编写一个解析工具类 </p>
<p> <strong>JsonUtil</strong></p>
<pre><code>public class JsonUtil {
    public static Object parse(String json, Type type) {
        JSONObject object = null;
        try {
            object = new JSONObject(json);
            int status = object.getInt(&quot;status&quot;);
            String msg = object.getString(&quot;msg&quot;);
            Gson gson = new Gson();
            if (status == 1) {//数据请求失败
                return gson.fromJson(json, type);
            } else if (status == 0) {//数据请求成功
                if (!object.getString(&quot;data&quot;).equals(&quot;&quot;) &amp;&amp; !&quot;&quot;.equals(object.getString(&quot;data&quot;))) {//数据不为空
                    return gson.fromJson(json, type);
                } else {
                    return null;
                }
            }
        } catch (JSONException e) {
            e.printStackTrace();
            LogUtils.e(e.getMessage());
            return null;
        } catch (JsonSyntaxException e) {
            e.printStackTrace();
            LogUtils.e(e.getMessage());
            return null;
        } catch (NullPointerException e) {
            e.printStackTrace();
            LogUtils.e(e.getMessage());
            return null;
        }
        return null;
    }
}
</code></pre><p>  调用：</p>
<pre><code>LogUtils.d(data);
Type     type = new TypeToken&lt;TestBean&gt;() {}.getType();
        try {
            TestBean bean = (TestBean) JsonUtil.parse(data, type);
            if (bean != null) {
                if (bean.getStatus() == 0) {
                    LogUtils.d(&quot;DATA::&quot; + bean.getData().getData());
                    if (bean.getData().getData() == null) {
                        LogUtils.d(&quot;数据为空::::::::&quot;);
                    } else {
                        LogUtils.d(bean.getData().toString());
                    }
                } else {
                    LogUtils.d(&quot;数据加载失败&quot;);
                }
            } else {
                LogUtils.d(&quot;数据为空..........&quot;);
            }
        } catch (ClassCastException e) {
            e.printStackTrace();
            LogUtils.e(e.getMessage());
        }
</code></pre></li>
</ol>
<blockquote>
<p><strong>ps</strong>:该解决办法自己做过测试可行，但是并不完美，以后有更好的解决办法在来修改</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android 序列化与反序列化]]></title>
      <url>https://feealan.github.io/2016/07/17/Serialize-and-Deserialize/</url>
      <content type="html"><![CDATA[<h2 id="1、什么是序列化与反序列化"><a href="#1、什么是序列化与反序列化" class="headerlink" title="1、什么是序列化与反序列化"></a>1、什么是序列化与反序列化</h2><blockquote>
<p>序列化：将数据结构或对象转换成二进制串的过程</p>
<p>反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程</p>
</blockquote>
<h2 id="2、为什么要序列化与反序列化"><a href="#2、为什么要序列化与反序列化" class="headerlink" title="2、为什么要序列化与反序列化"></a>2、为什么要序列化与反序列化</h2><blockquote>
<p>由于在系统底层，数据的传输形式是简单的字节序列形式传递，即在底层，系统不认识对象，只认识字节序列，而为了达到进程通讯的目的，需要先将数据序列化，而序列化就是将对象转化字节序列的过程。</p>
<p>相反地，当字节序列被运到相应的进程的时候，进程为了识别这些数据，就要将其反序列化，即把字节序列转化为对象。</p>
</blockquote>
<a id="more"></a>
<h2 id="3、Android-什么时候使用到序列化"><a href="#3、Android-什么时候使用到序列化" class="headerlink" title="3、Android 什么时候使用到序列化"></a>3、Android 什么时候使用到序列化</h2><h3 id="1、使用Intent传递对象时，该对象必须序列化"><a href="#1、使用Intent传递对象时，该对象必须序列化" class="headerlink" title="1、使用Intent传递对象时，该对象必须序列化"></a>1、使用Intent传递对象时，该对象必须序列化</h3><pre><code>Intent intent = new Intent(MainActivity.this, TestActivity.class);
intent.putExtra(&quot;user&quot;, new TestBean());
startActivity(intent);
</code></pre><h3 id="2、把内存中的对象写入到硬盘的时候"><a href="#2、把内存中的对象写入到硬盘的时候" class="headerlink" title="2、把内存中的对象写入到硬盘的时候"></a>2、把内存中的对象写入到硬盘的时候</h3><pre><code>/**
 * 序列化对象
 * 
 * @param person
 * @throws IOException
 * @return
 */
private String serialize(Person person) throws IOException {
    startTime = System.currentTimeMillis();
    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
    ObjectOutputStream objectOutputStream = new ObjectOutputStream(
            byteArrayOutputStream);
    objectOutputStream.writeObject(person);
    String serStr = byteArrayOutputStream.toString(&quot;ISO-8859-1&quot;);
    serStr = java.net.URLEncoder.encode(serStr, &quot;UTF-8&quot;);
    objectOutputStream.close();
    byteArrayOutputStream.close();
    Log.d(&quot;serial&quot;, &quot;serialize str =&quot; + serStr);
    endTime = System.currentTimeMillis();
    Log.d(&quot;serial&quot;, &quot;序列化耗时为:&quot; + (endTime - startTime));
    return serStr;
}
</code></pre><h3 id="3、想在网络中传送和接收对象的时候"><a href="#3、想在网络中传送和接收对象的时候" class="headerlink" title="3、想在网络中传送和接收对象的时候"></a>3、想在网络中传送和接收对象的时候</h3><pre><code>使用json来进行客户端和服务端通信，json的解析与生成就是数据的序列化和反序列化
</code></pre><h2 id="4、Android-对象序列化"><a href="#4、Android-对象序列化" class="headerlink" title="4、Android 对象序列化"></a>4、Android 对象序列化</h2><h3 id="1、实现Serializable接口"><a href="#1、实现Serializable接口" class="headerlink" title="1、实现Serializable接口"></a>1、实现Serializable接口</h3><pre><code>public class TestBean  implements Serializable{
    private String name;
    private String sex;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }
}
</code></pre><h3 id="2、实现Parcelable接口"><a href="#2、实现Parcelable接口" class="headerlink" title="2、实现Parcelable接口"></a>2、实现Parcelable接口</h3><pre><code>public class TestBean implements Parcelable {
    private String name;
    private String sex;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(this.name);
        dest.writeString(this.sex);
    }

    public TestBean() {
    }

    protected TestBean(Parcel in) {
        this.name = in.readString();
        this.sex = in.readString();
    }

    public static final Parcelable.Creator&lt;TestBean&gt; CREATOR = new Parcelable.Creator&lt;TestBean&gt;() {
        @Override
        public TestBean createFromParcel(Parcel source) {
            return new TestBean(source);
        }

        @Override
        public TestBean[] newArray(int size) {
            return new TestBean[size];
        }
    };
}
</code></pre><p>推荐一个android studio实现Parcelable接口的插件，可以快速实现Parcelable自动生成代码</p>
<blockquote>
<p><strong>File</strong>&gt;&gt;&gt;<strong>Setting</strong>&gt;&gt;&gt;<strong>Plugins</strong>&gt;&gt;&gt;<strong>Browse respositories</strong>&gt;&gt;&gt;搜索<strong>Parcelable</strong>&gt;&gt;&gt;<br>选择<strong>Android Parcelable code generator</strong>&gt;&gt;&gt;<strong>install</strong></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>https://feealan.github.io/2016/07/14/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
