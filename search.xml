<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[网络请求json解析时遇到的坑]]></title>
      <url>https://feealan.github.io/2016/07/18/network-gson-parse/</url>
      <content type="html"><![CDATA[<h1 id="1、网络请求数据返回的几种情况"><a href="#1、网络请求数据返回的几种情况" class="headerlink" title="1、网络请求数据返回的几种情况"></a>1、网络请求数据返回的几种情况</h1><ol>
<li>http返回状态码为404或者500错误，即请求未成功</li>
<li>http返回状态码为200，请求成功</li>
</ol>
<h1 id="2、网络请求数据成功返回的json数据格式"><a href="#2、网络请求数据成功返回的json数据格式" class="headerlink" title="2、网络请求数据成功返回的json数据格式"></a>2、网络请求数据成功返回的json数据格式</h1><pre><code>{
    &quot;data&quot;: &quot;&quot;,
    &quot;msg&quot;: &quot;success&quot;,
    &quot;status&quot;: 0  //这里 0代表成功  1代表失败
}     
</code></pre><p> 一般数据最外层都相同</p>
<blockquote>
<p><strong>status</strong> 即客户端和服务端商量好的状态码</p>
<p><strong>msg</strong>  即对status的一个解释</p>
<p><strong>data</strong> 存放数据</p>
</blockquote>
<a id="more"></a>
<h1 id="3、网络数据请求成功的几种情况"><a href="#3、网络数据请求成功的几种情况" class="headerlink" title="3、网络数据请求成功的几种情况"></a>3、网络数据请求成功的几种情况</h1><ol>
<li><strong>status</strong>为 1，数据请求失败，<strong>msg</strong>信息为 fail</li>
<li><strong>status</strong>为 0，数据加载成功，<strong>msg</strong>信息为 success，<strong>data</strong>内有数据</li>
<li><strong>status</strong>为 0，数据加载成功，<strong>msg</strong>信息为 success，<strong>data</strong>数据为空 显示为 <strong>“”</strong></li>
</ol>
<h1 id="4、针对上面的这三种情况，如果不做处理直接用Gson则会报以下的异常"><a href="#4、针对上面的这三种情况，如果不做处理直接用Gson则会报以下的异常" class="headerlink" title="4、针对上面的这三种情况，如果不做处理直接用Gson则会报以下的异常"></a>4、针对上面的这三种情况，如果不做处理直接用Gson则会报以下的异常</h1><pre><code>com.google.gson.JsonSyntaxException: java.lang.IllegalStateException: Expected BEGIN_OBJECT but was STRING at line 1 column 11
                                                                         at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter.read(ReflectiveTypeAdapterFactory.java:176)
                                                                         at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$1.read(ReflectiveTypeAdapterFactory.java:93)
                                                                         at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter.read(ReflectiveTypeAdapterFactory.java:172)
                                                                         at com.google.gson.Gson.fromJson(Gson.java:803)
                                                                         at com.google.gson.Gson.fromJson(Gson.java:768)
                                                                         at com.google.gson.Gson.fromJson(Gson.java:717)
                                                                         at com.google.gson.Gson.fromJson(Gson.java:689)
</code></pre><h1 id="5、解决办法（填坑过程）"><a href="#5、解决办法（填坑过程）" class="headerlink" title="5、解决办法（填坑过程）"></a>5、解决办法（填坑过程）</h1><ol>
<li>在使用gson解析时，对其抓取异常，在抓取到的异常中直接报系统错误。当时是有一种偷懒的想法，后来想想，这种办法把 请求成功中的第一第二种情况合到一起解决了，<strong>不可取</strong></li>
<li><p>和后台商量，如果数据加载失败，则返回的json为</p>
<pre><code>{&quot;msg&quot;: &quot;fail&quot;,&quot;status&quot;: 1}
</code></pre><p>如果数据为空，则返回的data也必须和有数据时类型一样，即下面这种情况，数据为空时给其一个默认值</p>
<p> 正常数据：</p>
<pre><code>{
    &quot;data&quot;: {
        &quot;username&quot;: &quot;fee&quot;,
        &quot;age&quot;: 20,
        &quot;sex&quot;: 1
    },
    &quot;msg&quot;: &quot;success&quot;,
    &quot;status&quot;: 0
}
</code></pre><p> 数据为空：</p>
<pre><code>{
    &quot;data&quot;: {},
    &quot;msg&quot;: &quot;success&quot;,
    &quot;status&quot;: 0
}
</code></pre><p> 默认值设置标准：正常情况下返回的类型是什么，则默认值的类型是什么<br> 解释：</p>
<ol>
<li>如果返回的数据为字符串，为空返回 <strong>“”</strong></li>
<li>如果返回的数据为对象，为空返回 <strong>｛｝</strong></li>
<li>如果返回的数据为集合，为空返回 <strong>[]</strong></li>
</ol>
</li>
<li><p>客户端在解析数据时，编写一个解析工具类 </p>
<p> <strong>JsonUtil</strong></p>
<pre><code>public class JsonUtil {
    public static Object parse(String json, Type type) {
        JSONObject object = null;
        try {
            object = new JSONObject(json);
            int status = object.getInt(&quot;status&quot;);
            String msg = object.getString(&quot;msg&quot;);
            Gson gson = new Gson();
            if (status == 1) {//数据请求失败
                return gson.fromJson(json, type);
            } else if (status == 0) {//数据请求成功
                if (!object.getString(&quot;data&quot;).equals(&quot;&quot;) &amp;&amp; !&quot;&quot;.equals(object.getString(&quot;data&quot;))) {//数据不为空
                    return gson.fromJson(json, type);
                } else {
                    return null;
                }
            }
        } catch (JSONException e) {
            e.printStackTrace();
            LogUtils.e(e.getMessage());
            return null;
        } catch (JsonSyntaxException e) {
            e.printStackTrace();
            LogUtils.e(e.getMessage());
            return null;
        } catch (NullPointerException e) {
            e.printStackTrace();
            LogUtils.e(e.getMessage());
            return null;
        }
        return null;
    }
}
</code></pre><p>  调用：</p>
<pre><code>LogUtils.d(data);
Type     type = new TypeToken&lt;TestBean&gt;() {}.getType();
        try {
            TestBean bean = (TestBean) JsonUtil.parse(data, type);
            LogUtils.d(bean.toString());
            if (bean.getStatus() == 0) {
                LogUtils.d(&quot;DATA::&quot; + bean.getData().getData());
                if (bean.getData().getData() == null) {
                    LogUtils.d(&quot;数据为空&quot;);
                } else {
                    LogUtils.d(bean.getData().toString());
                }
            } else {
                LogUtils.d(&quot;数据加载失败&quot;);
            }
        } catch (ClassCastException e) {
            e.printStackTrace();
            LogUtils.e(e.getMessage());
        }
</code></pre></li>
</ol>
<blockquote>
<p><strong>ps</strong>:该解决办法自己做过测试可行，但是并不完美，以后有更好的解决办法在来修改</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android 序列化与反序列化]]></title>
      <url>https://feealan.github.io/2016/07/17/Serialize-and-Deserialize/</url>
      <content type="html"><![CDATA[<h2 id="1、什么是序列化与反序列化"><a href="#1、什么是序列化与反序列化" class="headerlink" title="1、什么是序列化与反序列化"></a>1、什么是序列化与反序列化</h2><blockquote>
<p>序列化：将数据结构或对象转换成二进制串的过程</p>
<p>反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程</p>
</blockquote>
<h2 id="2、为什么要序列化与反序列化"><a href="#2、为什么要序列化与反序列化" class="headerlink" title="2、为什么要序列化与反序列化"></a>2、为什么要序列化与反序列化</h2><blockquote>
<p>由于在系统底层，数据的传输形式是简单的字节序列形式传递，即在底层，系统不认识对象，只认识字节序列，而为了达到进程通讯的目的，需要先将数据序列化，而序列化就是将对象转化字节序列的过程。</p>
<p>相反地，当字节序列被运到相应的进程的时候，进程为了识别这些数据，就要将其反序列化，即把字节序列转化为对象。</p>
</blockquote>
<a id="more"></a>
<h2 id="3、Android-什么时候使用到序列化"><a href="#3、Android-什么时候使用到序列化" class="headerlink" title="3、Android 什么时候使用到序列化"></a>3、Android 什么时候使用到序列化</h2><h3 id="1、使用Intent传递对象时，该对象必须序列化"><a href="#1、使用Intent传递对象时，该对象必须序列化" class="headerlink" title="1、使用Intent传递对象时，该对象必须序列化"></a>1、使用Intent传递对象时，该对象必须序列化</h3><pre><code>Intent intent = new Intent(MainActivity.this, TestActivity.class);
intent.putExtra(&quot;user&quot;, new TestBean());
startActivity(intent);
</code></pre><h3 id="2、把内存中的对象写入到硬盘的时候"><a href="#2、把内存中的对象写入到硬盘的时候" class="headerlink" title="2、把内存中的对象写入到硬盘的时候"></a>2、把内存中的对象写入到硬盘的时候</h3><pre><code>/**
 * 序列化对象
 * 
 * @param person
 * @throws IOException
 * @return
 */
private String serialize(Person person) throws IOException {
    startTime = System.currentTimeMillis();
    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
    ObjectOutputStream objectOutputStream = new ObjectOutputStream(
            byteArrayOutputStream);
    objectOutputStream.writeObject(person);
    String serStr = byteArrayOutputStream.toString(&quot;ISO-8859-1&quot;);
    serStr = java.net.URLEncoder.encode(serStr, &quot;UTF-8&quot;);
    objectOutputStream.close();
    byteArrayOutputStream.close();
    Log.d(&quot;serial&quot;, &quot;serialize str =&quot; + serStr);
    endTime = System.currentTimeMillis();
    Log.d(&quot;serial&quot;, &quot;序列化耗时为:&quot; + (endTime - startTime));
    return serStr;
}
</code></pre><h3 id="3、想在网络中传送和接收对象的时候"><a href="#3、想在网络中传送和接收对象的时候" class="headerlink" title="3、想在网络中传送和接收对象的时候"></a>3、想在网络中传送和接收对象的时候</h3><pre><code>使用json来进行客户端和服务端通信，json的解析与生成就是数据的序列化和反序列化
</code></pre><h2 id="4、Android-对象序列化"><a href="#4、Android-对象序列化" class="headerlink" title="4、Android 对象序列化"></a>4、Android 对象序列化</h2><h3 id="1、实现Serializable接口"><a href="#1、实现Serializable接口" class="headerlink" title="1、实现Serializable接口"></a>1、实现Serializable接口</h3><pre><code>public class TestBean  implements Serializable{
    private String name;
    private String sex;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }
}
</code></pre><h3 id="2、实现Parcelable接口"><a href="#2、实现Parcelable接口" class="headerlink" title="2、实现Parcelable接口"></a>2、实现Parcelable接口</h3><pre><code>public class TestBean implements Parcelable {
    private String name;
    private String sex;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(this.name);
        dest.writeString(this.sex);
    }

    public TestBean() {
    }

    protected TestBean(Parcel in) {
        this.name = in.readString();
        this.sex = in.readString();
    }

    public static final Parcelable.Creator&lt;TestBean&gt; CREATOR = new Parcelable.Creator&lt;TestBean&gt;() {
        @Override
        public TestBean createFromParcel(Parcel source) {
            return new TestBean(source);
        }

        @Override
        public TestBean[] newArray(int size) {
            return new TestBean[size];
        }
    };
}
</code></pre><p>推荐一个android studio实现Parcelable接口的插件，可以快速实现Parcelable自动生成代码</p>
<blockquote>
<p><strong>File</strong>&gt;&gt;&gt;<strong>Setting</strong>&gt;&gt;&gt;<strong>Plugins</strong>&gt;&gt;&gt;<strong>Browse respositories</strong>&gt;&gt;&gt;搜索<strong>Parcelable</strong>&gt;&gt;&gt;<br>选择<strong>Android Parcelable code generator</strong>&gt;&gt;&gt;<strong>install</strong></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>https://feealan.github.io/2016/07/14/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
